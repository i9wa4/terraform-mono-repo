SHELL := /usr/bin/env bash
.SHELLFLAGS := -o errexit -o nounset -o pipefail -o posix -c
.DEFAULT_GOAL := help

# --- Configuration ---
# SERVICE: 操作対象のTerraformプロジェクトディレクトリ名 (例: app-lambda, infra-main)
# Must be passed to make, e.g., make plan SERVICE=app-lambda
SERVICE ?= $(error SERVICE is not set. Please specify SERVICE (e.g., app-lambda, infra-main))
# ENVIRONMENT: デプロイ環境 (例: dev, stg, prod)
ENVIRONMENT ?= dev

# Directories (assuming Makefile is in the repo root)
TERRAFORM_DIR := $(SERVICE)
# For app-lambda service, specify Dockerfile location and app source
DOCKERFILE_PATH := $(SERVICE)/Dockerfile
APP_SRC_DIR     := $(SERVICE)/src

# Terraform variables
# Assumes tfvars files like app-lambda/dev.tfvars, app-lambda/prod.tfvars etc.
TF_VAR_FILE := $(ENVIRONMENT).tfvars # This file should exist within TERRAFORM_DIR
TF_VAR_FILE_OPT := -var-file=$(TF_VAR_FILE)
# Additional Terraform options passed via command line
TF_OPT ?=

# Docker/ECR variables (set these via GitHub Actions vars/secrets or local env)
AWS_REGION ?= ap-northeast-1 # Or your preferred region
ECR_REGISTRY ?= # Example: 123456789012.dkr.ecr.ap-northeast-1.amazonaws.com (REQUIRED)
# Default ECR repository name based on SERVICE, can be overridden
ECR_REPOSITORY_NAME ?= $(SERVICE)-$(ENVIRONMENT)-repo
# Default Lambda function name, can be overridden
LAMBDA_FUNCTION_NAME ?= $(SERVICE)-$(ENVIRONMENT)-function
# Image tag, defaults to short git commit hash
IMAGE_TAG ?= $(shell git rev-parse --short HEAD)
# Full image name with tag
FULL_ECR_IMAGE_NAME_WITH_TAG := $(ECR_REGISTRY)/$(ECR_REPOSITORY_NAME):$(IMAGE_TAG)
# Initial image URI for Terraform (Lambda infra deployment). This is a placeholder or bootstrap image.
# This can be passed via TF_OPT or a variable in your tfvars file if needed.
# For example, terraform plan -var="initial_lambda_image_uri=..."
INITIAL_LAMBDA_IMAGE_URI ?= $(ECR_REGISTRY)/$(ECR_REPOSITORY_NAME):initial-infra-deploy


# Phony targets
.PHONY: help ecr-login docker-build docker-push deploy-lambda-image \
	init validate plan apply destroy-plan destroy fmt \
	app-lambda-dev-plan app-lambda-dev-apply app-lambda-prod-plan app-lambda-prod-apply \
	infra-main-dev-plan infra-main-dev-apply infra-main-prod-plan infra-main-prod-apply

help: ## Print this help
	@echo 'Usage: make [target] SERVICE=<service_name> [ENVIRONMENT=<env_name>] [VAR=value ...]'
	@echo ''
	@echo 'Required:'
	@echo '  SERVICE         : Target service/project directory (e.g., app-lambda, infra-main).'
	@echo ''
	@echo 'Optional:'
	@echo '  ENVIRONMENT     : Target environment (default: dev).'
	@echo '  AWS_REGION      : AWS Region (default: ap-northeast-1).'
	@echo '  ECR_REGISTRY    : ECR Registry URL (REQUIRED for ECR/Lambda image tasks).'
	@echo '  ECR_REPOSITORY_NAME: ECR Repository name (default: $(SERVICE)-$(ENVIRONMENT)-repo).'
	@echo '  LAMBDA_FUNCTION_NAME: Lambda function name for image update (default: $(SERVICE)-$(ENVIRONMENT)-function).'
	@echo '  IMAGE_TAG       : Docker image tag (default: git short commit hash).'
	@echo '  TF_OPT          : Additional options for terraform plan/apply.'
	@echo ''
	@echo 'Targets:'
	@awk 'BEGIN {FS = ":.*?## "} /^[a-zA-Z0-9_-]+:.*?## / {printf "\033[36m%-30s\033[0m %s\n", $$1, $$2}' $(MAKEFILE_LIST)


# --- Docker & ECR Targets (Primarily for 'app-lambda' type services) ---
ecr-login: ## Login to Amazon ECR
ifeq ($(ECR_REGISTRY),)
	$(error ECR_REGISTRY is not set. Please provide it.)
endif
	@echo ">>> Logging in to ECR registry $(ECR_REGISTRY) in region $(AWS_REGION)"
	aws ecr get-login-password --region $(AWS_REGION) | docker login --username AWS --password-stdin $(ECR_REGISTRY)

docker-build: ## Build Docker image for the specified SERVICE
	@echo ">>> Building Docker image for $(SERVICE) from $(DOCKERFILE_PATH)"
	@echo "    Image will be: $(FULL_ECR_IMAGE_NAME_WITH_TAG)"
	docker build -t $(FULL_ECR_IMAGE_NAME_WITH_TAG) -f $(DOCKERFILE_PATH) $(TERRAFORM_DIR) --platform=linux/arm64

docker-push: ## Push Docker image to ECR
	@echo ">>> Pushing Docker image $(FULL_ECR_IMAGE_NAME_WITH_TAG) to ECR"
	docker push $(FULL_ECR_IMAGE_NAME_WITH_TAG)

# This target updates Lambda image directly, bypassing Terraform apply for faster deployments.
# Corresponds to GitHub Actions workflow: 05-app-lambda-image-deploy.yml
deploy-lambda-image: ecr-login docker-build docker-push ## Build, push image, and update Lambda function code
	@echo ">>> Deploying image $(FULL_ECR_IMAGE_NAME_WITH_TAG) to Lambda function $(LAMBDA_FUNCTION_NAME)"
	aws lambda update-function-code \
		--function-name $(LAMBDA_FUNCTION_NAME) \
		--image-uri $(FULL_ECR_IMAGE_NAME_WITH_TAG) \
		--region $(AWS_REGION)
	@echo ">>> Lambda function $(LAMBDA_FUNCTION_NAME) updated successfully."


# --- Terraform Common Targets ---
# These targets are called by GitHub Actions and can also be used locally.
# Example: make plan SERVICE=app-lambda ENVIRONMENT=dev
init: ## Initialize Terraform for the SERVICE and ENVIRONMENT
	@echo ">>> Initializing Terraform in $(TERRAFORM_DIR) for $(SERVICE)/$(ENVIRONMENT)"
	terraform -chdir=$(TERRAFORM_DIR) init \
		-backend-config="bucket=$(shell aws ssm get-parameter --name /terraform/s3_backend/bucket_name --query Parameter.Value --output text)" \
		-backend-config="key=$(SERVICE)/$(ENVIRONMENT)/terraform.tfstate" \
		-backend-config="region=$(AWS_REGION)" \
		-backend-config="dynamodb_table=$(shell aws ssm get-parameter --name /terraform/s3_backend/dynamodb_table --query Parameter.Value --output text)" \
		-reconfigure

validate: ## Validate Terraform configuration
	@echo ">>> Validating Terraform configuration in $(TERRAFORM_DIR)"
	terraform -chdir=$(TERRAFORM_DIR) validate

plan: init ## Create Terraform execution plan
	@echo ">>> Planning Terraform in $(TERRAFORM_DIR) for $(SERVICE)/$(ENVIRONMENT)"
	@echo "    Using var file: $(TERRAFORM_DIR)/$(TF_VAR_FILE)"
	@if [ ! -f "$(TERRAFORM_DIR)/$(TF_VAR_FILE)" ]; then \
		echo "Warning: TF_VAR_FILE '$(TERRAFORM_DIR)/$(TF_VAR_FILE)' not found. Proceeding without it."; \
		terraform -chdir=$(TERRAFORM_DIR) plan \
			-var="image_tag_for_infra_deploy=$(IMAGE_TAG)" \
			-var="initial_lambda_image_uri=$(INITIAL_LAMBDA_IMAGE_URI)" \
			-var="environment=$(ENVIRONMENT)" \
			-out=.terraform.plan.$(SERVICE).$(ENVIRONMENT).tfplan -no-color $(TF_OPT) ; \
	else \
		terraform -chdir=$(TERRAFORM_DIR) plan \
			-var="image_tag_for_infra_deploy=$(IMAGE_TAG)" \
			-var="initial_lambda_image_uri=$(INITIAL_LAMBDA_IMAGE_URI)" \
			-var-file=$(TF_VAR_FILE) \
			-out=.terraform.plan.$(SERVICE).$(ENVIRONMENT).tfplan -no-color $(TF_OPT) ; \
	fi


apply: init ## Apply Terraform plan
	@echo ">>> Applying Terraform plan for $(SERVICE)/$(ENVIRONMENT) from .terraform.plan.$(SERVICE).$(ENVIRONMENT).tfplan"
	terraform -chdir=$(TERRAFORM_DIR) apply -auto-approve ".terraform.plan.$(SERVICE).$(ENVIRONMENT).tfplan"

destroy-plan: init ## Create Terraform destroy plan
	@echo ">>> Planning Terraform destroy in $(TERRAFORM_DIR) for $(SERVICE)/$(ENVIRONMENT)"
	@if [ ! -f "$(TERRAFORM_DIR)/$(TF_VAR_FILE)" ]; then \
		echo "Warning: TF_VAR_FILE '$(TERRAFORM_DIR)/$(TF_VAR_FILE)' not found. Proceeding without it."; \
		terraform -chdir=$(TERRAFORM_DIR) plan -destroy \
			-var="environment=$(ENVIRONMENT)" \
			-out=.terraform.plan.destroy.$(SERVICE).$(ENVIRONMENT).tfplan -no-color $(TF_OPT) ; \
	else \
		terraform -chdir=$(TERRAFORM_DIR) plan -destroy \
			-var-file=$(TF_VAR_FILE) \
			-out=.terraform.plan.destroy.$(SERVICE).$(ENVIRONMENT).tfplan -no-color $(TF_OPT) ; \
	fi

destroy: init ## Destroy Terraform resources based on destroy plan
	@echo ">>> Destroying Terraform resources for $(SERVICE)/$(ENVIRONMENT) using .terraform.plan.destroy.$(SERVICE).$(ENVIRONMENT).tfplan"
	terraform -chdir=$(TERRAFORM_DIR) apply -auto-approve ".terraform.plan.destroy.$(SERVICE).$(ENVIRONMENT).tfplan"

fmt: ## Format Terraform files
	@echo ">>> Formatting Terraform files in $(TERRAFORM_DIR)"
	terraform -chdir=$(TERRAFORM_DIR) fmt -recursive


# --- Convenience Aliases for Local Development (Example) ---
# You can define specific aliases if needed, or just use the common targets with parameters.
# Example: make app-lambda-dev-plan (calls 'make plan SERVICE=app-lambda ENVIRONMENT=dev')

define SERVICE_ENV_TARGETS
# Targets for $(1) service in $(2) environment
$(1)-$(2)-plan:
	@$$(MAKE) plan SERVICE=$(1) ENVIRONMENT=$(2) TF_OPT="$$(TF_OPT)"
$(1)-$(2)-apply:
	@$$(MAKE) apply SERVICE=$(1) ENVIRONMENT=$(2)
# Add more aliases as needed (e.g., destroy, validate)

# Help for these specific alias targets
help::
	@echo ''
	@printf "\033[36m%-30s\033[0m %s\n" "$(1)-$(2)-plan" "Plan for $(1) in $(2)"
	@printf "\033[36m%-30s\033[0m %s\n" "$(1)-$(2)-apply" "Apply for $(1) in $(2)"
endef

# Generate aliases for common combinations
$(foreach s_alias, app-lambda infra-main, \
  $(foreach e_alias, dev prod, \
    $(eval $(call SERVICE_ENV_TARGETS,$(s_alias),$(e_alias)))))

# Specific alias for app-lambda image deployment for dev environment
app-lambda-dev-deploy-image:
	@$(MAKE) deploy-lambda-image SERVICE=app-lambda ENVIRONMENT=dev
help::
	@printf "\033[36m%-30s\033[0m %s\n" "app-lambda-dev-deploy-image" "Build, Push & Update Lambda image (app-lambda, dev)"
